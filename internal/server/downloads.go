package server

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-chi/chi/v5"
)

func (s *Server) handleDownloadInstallScript(w http.ResponseWriter, r *http.Request) {
	baseURL := s.getBaseURL(r)
	script := generateInstallScript(baseURL)

	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.Header().Set("Content-Disposition", "inline; filename=install.sh")
	w.Write([]byte(script))
}

func (s *Server) handleDownloadBinary(w http.ResponseWriter, r *http.Request) {
	filename := chi.URLParam(r, "filename")

	// Prevent directory traversal
	if strings.Contains(filename, "..") || strings.Contains(filename, "/") || strings.Contains(filename, "\\") {
		http.Error(w, "invalid filename", http.StatusBadRequest)
		return
	}

	if !strings.HasSuffix(filename, ".tar.gz") {
		http.Error(w, "only .tar.gz files are served", http.StatusBadRequest)
		return
	}

	if _, err := os.Stat(s.cfg.BinariesDir); os.IsNotExist(err) {
		writeJSON(w, http.StatusNotFound, map[string]string{
			"error": "binary distribution not configured — place client .tar.gz files in " + s.cfg.BinariesDir,
		})
		return
	}

	filePath := filepath.Join(s.cfg.BinariesDir, filename)
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		http.Error(w, "binary not found", http.StatusNotFound)
		return
	}

	s.logger.Info("serving binary download", "filename", filename, "remote_addr", r.RemoteAddr)
	w.Header().Set("Content-Type", "application/gzip")
	http.ServeFile(w, r, filePath)
}

func (s *Server) handleListDownloads(w http.ResponseWriter, r *http.Request) {
	baseURL := s.getBaseURL(r)

	entries, err := os.ReadDir(s.cfg.BinariesDir)
	if err != nil {
		writeJSON(w, http.StatusOK, map[string]interface{}{
			"install_script": baseURL + "/download/install.sh",
			"binaries":       []string{},
			"note":           "no binaries available — place client .tar.gz files in " + s.cfg.BinariesDir,
		})
		return
	}

	var binaries []map[string]string
	for _, e := range entries {
		if !e.IsDir() && strings.HasSuffix(e.Name(), ".tar.gz") {
			info, _ := e.Info()
			binaries = append(binaries, map[string]string{
				"name": e.Name(),
				"url":  baseURL + "/download/" + e.Name(),
				"size": fmt.Sprintf("%d", info.Size()),
			})
		}
	}
	if binaries == nil {
		binaries = []map[string]string{}
	}

	writeJSON(w, http.StatusOK, map[string]interface{}{
		"install_script": baseURL + "/download/install.sh",
		"binaries":       binaries,
	})
}

// getBaseURL determines the server's public URL.
// Uses ExternalURL from config if set, otherwise infers from request headers.
func (s *Server) getBaseURL(r *http.Request) string {
	if s.cfg.ExternalURL != "" {
		return strings.TrimRight(s.cfg.ExternalURL, "/")
	}

	scheme := "http"
	if s.cfg.TLSMode != "" && s.cfg.TLSMode != "none" {
		scheme = "https"
	}
	if proto := r.Header.Get("X-Forwarded-Proto"); proto != "" {
		scheme = proto
	}

	host := r.Host
	if fwdHost := r.Header.Get("X-Forwarded-Host"); fwdHost != "" {
		host = fwdHost
	}

	return fmt.Sprintf("%s://%s", scheme, host)
}

func generateInstallScript(baseURL string) string {
	return fmt.Sprintf(`#!/bin/sh
set -e

# MachineMon Client Installer
# Generated by MachineMon Server at %[1]s
#
# Usage:
#   curl -sSL %[1]s/download/install.sh | sh
#   curl -sSL %[1]s/download/install.sh | sh -s -- --insecure   (for self-signed certs)

INSTALL_DIR="/usr/local/bin"
BINARY="machinemon-client"
BASE_URL="%[1]s"
INSECURE=""

for arg in "$@"; do
    case "$arg" in
        --insecure) INSECURE="--insecure" ;;
    esac
done

detect_platform() {
    OS=$(uname -s | tr '[:upper:]' '[:lower:]')
    ARCH=$(uname -m)

    case "$ARCH" in
        x86_64|amd64)  ARCH="amd64" ;;
        aarch64|arm64) ARCH="arm64" ;;
        armv7*)        ARCH="armv7" ;;
        armv6*)        ARCH="armv6" ;;
        arm*)
            if [ -f /proc/cpuinfo ]; then
                ARM_VER=$(grep -oP 'model name.*ARMv\K[0-9]+' /proc/cpuinfo 2>/dev/null || echo "6")
                if [ "$ARM_VER" -ge 7 ] 2>/dev/null; then
                    ARCH="armv7"
                else
                    ARCH="armv6"
                fi
            else
                ARCH="armv6"
            fi
            ;;
        *)
            echo "Error: unsupported architecture: $ARCH"
            exit 1
            ;;
    esac

    case "$OS" in
        linux)  OS="linux" ;;
        darwin) OS="darwin" ;;
        *)
            echo "Error: unsupported OS: $OS"
            exit 1
            ;;
    esac

    PLATFORM="${OS}-${ARCH}"
    echo "Detected platform: $PLATFORM"
}

download_binary() {
    DOWNLOAD_NAME="${BINARY}-${PLATFORM}"
    URL="${BASE_URL}/download/${DOWNLOAD_NAME}.tar.gz"

    echo "Downloading from ${URL}..."

    TMP_DIR=$(mktemp -d)
    trap "rm -rf $TMP_DIR" EXIT

    CURL_OPTS="-sSL"
    WGET_OPTS="-q"
    if [ -n "$INSECURE" ]; then
        CURL_OPTS="$CURL_OPTS --insecure"
        WGET_OPTS="$WGET_OPTS --no-check-certificate"
    fi

    if command -v curl >/dev/null 2>&1; then
        curl $CURL_OPTS "$URL" -o "$TMP_DIR/archive.tar.gz"
    elif command -v wget >/dev/null 2>&1; then
        wget $WGET_OPTS "$URL" -O "$TMP_DIR/archive.tar.gz"
    else
        echo "Error: curl or wget is required"
        exit 1
    fi

    cd "$TMP_DIR"
    tar xzf archive.tar.gz

    if [ "$(id -u)" -eq 0 ]; then
        mv "$DOWNLOAD_NAME" "${INSTALL_DIR}/${BINARY}"
        chmod 755 "${INSTALL_DIR}/${BINARY}"
    else
        echo "Installing to ${INSTALL_DIR} requires root. Using sudo..."
        sudo mv "$DOWNLOAD_NAME" "${INSTALL_DIR}/${BINARY}"
        sudo chmod 755 "${INSTALL_DIR}/${BINARY}"
    fi

    echo "Installed ${BINARY} to ${INSTALL_DIR}/${BINARY}"
}

main() {
    echo "=== MachineMon Client Installer ==="
    echo "Server: %[1]s"
    echo ""

    detect_platform
    download_binary

    INSECURE_FLAG=""
    if [ -n "$INSECURE" ]; then
        INSECURE_FLAG=" --insecure"
    fi

    echo ""
    echo "Installation complete!"
    echo ""
    echo "Next steps:"
    echo "  1. Configure:          machinemon-client --setup --server=%[1]s${INSECURE_FLAG}"
    echo "  2. Install as service: sudo machinemon-client --service-install"
    echo "     (auto-detects systemd, sysvinit, openrc, upstart, or launchd)"
    echo ""
    echo "  3. Verify on the dashboard: %[1]s"
}

main "$@"
`, baseURL)
}
