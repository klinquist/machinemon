package server

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-chi/chi/v5"
)

func (s *Server) handleDownloadInstallScript(w http.ResponseWriter, r *http.Request) {
	baseURL := s.getBaseURL(r)
	script := generateInstallScript(baseURL)

	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.Header().Set("Content-Disposition", "inline; filename=install.sh")
	w.Write([]byte(script))
}

func (s *Server) handleDownloadBinary(w http.ResponseWriter, r *http.Request) {
	filename := chi.URLParam(r, "filename")

	// Prevent directory traversal
	if strings.Contains(filename, "..") || strings.Contains(filename, "/") || strings.Contains(filename, "\\") {
		http.Error(w, "invalid filename", http.StatusBadRequest)
		return
	}

	if !strings.HasSuffix(filename, ".tar.gz") {
		http.Error(w, "only .tar.gz files are served", http.StatusBadRequest)
		return
	}

	if _, err := os.Stat(s.cfg.BinariesDir); os.IsNotExist(err) {
		writeJSON(w, http.StatusNotFound, map[string]string{
			"error": "binary distribution not configured — place client .tar.gz files in " + s.cfg.BinariesDir,
		})
		return
	}

	filePath := filepath.Join(s.cfg.BinariesDir, filename)
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		http.Error(w, "binary not found", http.StatusNotFound)
		return
	}

	s.logger.Info("serving binary download", "filename", filename, "remote_addr", r.RemoteAddr)
	w.Header().Set("Content-Type", "application/gzip")
	http.ServeFile(w, r, filePath)
}

func (s *Server) handleListDownloads(w http.ResponseWriter, r *http.Request) {
	baseURL := s.getBaseURL(r)

	entries, err := os.ReadDir(s.cfg.BinariesDir)
	if err != nil {
		writeJSON(w, http.StatusOK, map[string]interface{}{
			"install_script": baseURL + "/download/install.sh",
			"binaries":       []string{},
			"note":           "no binaries available — place client .tar.gz files in " + s.cfg.BinariesDir,
		})
		return
	}

	var binaries []map[string]string
	for _, e := range entries {
		if !e.IsDir() && strings.HasSuffix(e.Name(), ".tar.gz") {
			info, _ := e.Info()
			binaries = append(binaries, map[string]string{
				"name": e.Name(),
				"url":  baseURL + "/download/" + e.Name(),
				"size": fmt.Sprintf("%d", info.Size()),
			})
		}
	}
	if binaries == nil {
		binaries = []map[string]string{}
	}

	writeJSON(w, http.StatusOK, map[string]interface{}{
		"install_script": baseURL + "/download/install.sh",
		"binaries":       binaries,
	})
}

// getBaseURL determines the server's public URL.
// Uses ExternalURL from config if set, otherwise infers from request headers.
func (s *Server) getBaseURL(r *http.Request) string {
	if s.cfg.ExternalURL != "" {
		return strings.TrimRight(s.cfg.ExternalURL, "/")
	}

	scheme := "http"
	if s.cfg.TLSMode != "" && s.cfg.TLSMode != "none" {
		scheme = "https"
	}
	if proto := r.Header.Get("X-Forwarded-Proto"); proto != "" {
		scheme = proto
	}

	host := r.Host
	if fwdHost := r.Header.Get("X-Forwarded-Host"); fwdHost != "" {
		host = fwdHost
	}

	return fmt.Sprintf("%s://%s", scheme, host)
}

func generateInstallScript(baseURL string) string {
	return fmt.Sprintf(`#!/bin/sh
set -e

# MachineMon Client Installer
# Generated by MachineMon Server at %[1]s
#
# Usage:
#   curl -sSL %[1]s/download/install.sh | sh
#   curl -sSL %[1]s/download/install.sh | sh -s -- --insecure   (for self-signed certs)
#   curl -sSL %[1]s/download/install.sh | sh -s -- --upgrade    (upgrade + restart service)

INSTALL_DIR="/usr/local/bin"
BINARY="machinemon-client"
BASE_URL="%[1]s"
INSECURE=""
UPGRADE=0

for arg in "$@"; do
    case "$arg" in
        --insecure) INSECURE="--insecure" ;;
        --upgrade) UPGRADE=1 ;;
    esac
done

detect_platform() {
    OS=$(uname -s | tr '[:upper:]' '[:lower:]')
    ARCH=$(uname -m)

    case "$ARCH" in
        x86_64|amd64)  ARCH="amd64" ;;
        aarch64|arm64) ARCH="arm64" ;;
        armv7*)        ARCH="armv7" ;;
        armv6*)        ARCH="armv6" ;;
        arm*)
            if [ -f /proc/cpuinfo ]; then
                ARM_VER=$(grep -oP 'model name.*ARMv\K[0-9]+' /proc/cpuinfo 2>/dev/null || echo "6")
                if [ "$ARM_VER" -ge 7 ] 2>/dev/null; then
                    ARCH="armv7"
                else
                    ARCH="armv6"
                fi
            else
                ARCH="armv6"
            fi
            ;;
        *)
            echo "Error: unsupported architecture: $ARCH"
            exit 1
            ;;
    esac

    case "$OS" in
        linux)  OS="linux" ;;
        darwin) OS="darwin" ;;
        *)
            echo "Error: unsupported OS: $OS"
            exit 1
            ;;
    esac

    PLATFORM="${OS}-${ARCH}"
    echo "Detected platform: $PLATFORM"
}

run_privileged() {
    if [ "$(id -u)" -eq 0 ]; then
        "$@"
    else
        sudo "$@"
    fi
}

run_launchctl_user() {
    if [ "$(id -u)" -eq 0 ] && [ -n "$SUDO_USER" ]; then
        sudo -u "$SUDO_USER" launchctl "$@"
    else
        launchctl "$@"
    fi
}

download_binary() {
    DOWNLOAD_NAME="${BINARY}-${PLATFORM}"
    URL="${BASE_URL}/download/${DOWNLOAD_NAME}.tar.gz"

    echo "Downloading from ${URL}..."

    TMP_DIR=$(mktemp -d)
    trap "rm -rf $TMP_DIR" EXIT

    CURL_OPTS="-sSL"
    WGET_OPTS="-q"
    if [ -n "$INSECURE" ]; then
        CURL_OPTS="$CURL_OPTS --insecure"
        WGET_OPTS="$WGET_OPTS --no-check-certificate"
    fi

    if command -v curl >/dev/null 2>&1; then
        curl $CURL_OPTS "$URL" -o "$TMP_DIR/archive.tar.gz"
    elif command -v wget >/dev/null 2>&1; then
        wget $WGET_OPTS "$URL" -O "$TMP_DIR/archive.tar.gz"
    else
        echo "Error: curl or wget is required"
        exit 1
    fi

    cd "$TMP_DIR"
    tar xzf archive.tar.gz

    if [ "$(id -u)" -eq 0 ]; then
        mv "$DOWNLOAD_NAME" "${INSTALL_DIR}/${BINARY}"
        chmod 755 "${INSTALL_DIR}/${BINARY}"
    else
        echo "Installing to ${INSTALL_DIR} requires root. Using sudo..."
        sudo mv "$DOWNLOAD_NAME" "${INSTALL_DIR}/${BINARY}"
        sudo chmod 755 "${INSTALL_DIR}/${BINARY}"
    fi

    echo "Installed ${BINARY} to ${INSTALL_DIR}/${BINARY}"
}

restart_launchd() {
    LABEL="com.machinemon.client"

    if [ "$(id -u)" -eq 0 ] && [ -n "$SUDO_USER" ]; then
        TARGET_UID=$(id -u "$SUDO_USER" 2>/dev/null || true)
        TARGET_HOME=$(dscl . -read "/Users/${SUDO_USER}" NFSHomeDirectory 2>/dev/null | awk '{print $2}')
        if [ -z "$TARGET_HOME" ]; then
            TARGET_HOME="/Users/${SUDO_USER}"
        fi
    else
        TARGET_UID=$(id -u)
        TARGET_HOME="$HOME"
    fi

    if [ -z "$TARGET_UID" ]; then
        echo "Warning: could not determine launchd user UID; skipping restart."
        return 1
    fi

    DOMAIN="gui/${TARGET_UID}"
    PLIST="${TARGET_HOME}/Library/LaunchAgents/${LABEL}.plist"

    if run_launchctl_user kickstart -k "${DOMAIN}/${LABEL}" >/dev/null 2>&1; then
        echo "Restarted launchd service: ${LABEL}"
        return 0
    fi

    if [ -f "$PLIST" ]; then
        run_launchctl_user bootstrap "${DOMAIN}" "$PLIST" >/dev/null 2>&1 || true
        if run_launchctl_user kickstart -k "${DOMAIN}/${LABEL}" >/dev/null 2>&1; then
            echo "Started launchd service: ${LABEL}"
            return 0
        fi
    fi

    echo "Could not auto-restart launchd service. Start it manually:"
    echo "  launchctl bootstrap ${DOMAIN} ${PLIST}"
    echo "  launchctl kickstart -k ${DOMAIN}/${LABEL}"
    return 1
}

restart_service_if_present() {
    if [ "$OS" = "darwin" ]; then
        restart_launchd || return 1
        return 0
    fi

    if command -v systemctl >/dev/null 2>&1; then
        if [ -f /etc/systemd/system/machinemon-client.service ] || \
           [ -f /usr/lib/systemd/system/machinemon-client.service ] || \
           [ -f /lib/systemd/system/machinemon-client.service ] || \
           systemctl list-unit-files 2>/dev/null | grep -q '^machinemon-client\.service'; then
            if run_privileged systemctl restart machinemon-client; then
                echo "Restarted systemd service: machinemon-client"
                return 0
            fi
        fi
    fi

    if command -v rc-service >/dev/null 2>&1; then
        if run_privileged rc-service machinemon-client restart >/dev/null 2>&1; then
            echo "Restarted OpenRC service: machinemon-client"
            return 0
        fi
    fi

    if command -v service >/dev/null 2>&1; then
        if run_privileged service machinemon-client restart >/dev/null 2>&1; then
            echo "Restarted service: machinemon-client"
            return 0
        fi
    fi

    if command -v initctl >/dev/null 2>&1; then
        if run_privileged restart machinemon-client >/dev/null 2>&1 || run_privileged start machinemon-client >/dev/null 2>&1; then
            echo "Restarted Upstart job: machinemon-client"
            return 0
        fi
    fi

    echo "No installed service detected (or restart failed)."
    echo "If needed, restart manually after upgrade."
    return 1
}

main() {
    echo "=== MachineMon Client Installer ==="
    echo "Server: %[1]s"
    echo ""

    detect_platform
    download_binary

    if [ "$UPGRADE" -eq 1 ]; then
        echo ""
        echo "Upgrade mode enabled: restarting service if installed..."
        restart_service_if_present || true
        echo ""
        echo "Upgrade complete."
        exit 0
    fi

    INSECURE_FLAG=""
    if [ -n "$INSECURE" ]; then
        INSECURE_FLAG=" --insecure"
    fi

    echo ""
    echo "Installation complete!"
    echo ""
    echo "Next steps:"
    echo "  1. Configure:          machinemon-client --setup --server=%[1]s${INSECURE_FLAG}"
    if [ "$OS" = "darwin" ]; then
        echo "  2. Install as service: machinemon-client --service-install"
    else
        echo "  2. Install as service: sudo machinemon-client --service-install"
    fi
    echo "     (auto-detects systemd, sysvinit, openrc, upstart, or launchd)"
    echo ""
    echo "  3. Verify on the dashboard: %[1]s"
}

main "$@"
`, baseURL)
}
